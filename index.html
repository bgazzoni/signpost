<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Signpost — Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
    html,body { height:100%; margin:0; }
    body { overflow:hidden; font-family: 'Bebas Neue', sans-serif; }
    canvas { display:block; }
    #ui { position: absolute; left: 50%; transform: translateX(-50%); bottom: 18px; display: flex; gap: 10px; align-items: center; z-index: 10; }
    #guessInput { width: 260px; padding: 12px 14px; border-radius: 10px; border: 2px solid #5d5f7c; background: rgba(255,255,255,0.03); color: #fff; font-family: 'Bebas Neue', sans-serif; font-size: 18px; text-align: center; outline: none; }
    #guessButton { padding: 12px 18px; border-radius: 10px; border: 2px solid #5d5f7c; background: #5d5f7c; color: #fff; font-family: 'Bebas Neue', sans-serif; font-size: 18px; cursor: pointer; }
    #suggestions { position: absolute; bottom: 65px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); border: 1px solid #5d5f7c; border-radius: 6px; max-height: 220px; overflow-y: auto; color: #fff; font-size: 16px; display: none; z-index: 11; min-width: 260px; }
    #suggestions div { padding: 6px 10px; cursor: pointer; }
    #suggestions div:hover { background: rgba(255,255,255,0.05); }
    #attempts { background: rgba(0,0,0,0.25); padding: 8px 12px; border-radius: 10px; color: #fff; border: 1px solid rgba(255,255,255,0.03); font-size: 14px; }
    #message { position: absolute; top: 18px; left: 50%; transform: translateX(-50%); color: #fff; background: rgba(0,0,0,0.35); padding: 8px 12px; border-radius: 8px; font-size: 14px; z-index: 10; pointer-events: none; }
  </style>
</head>
<body>
  <div id="ui">
    <input id="guessInput" type="text" placeholder="Type a country..." autocomplete="off" />
    <button id="guessButton">Guess</button>
    <div id="attempts">Revealed: <span id="revealedCount">1</span> / <span id="maxCount">10</span></div>
  </div>
  <div id="suggestions" role="listbox" aria-label="Country suggestions"></div>
  <div id="message">Guess the country where the pole is located.</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';

    // --- Basic scene ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#222033');
    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0,1.6,9);
    camera.lookAt(0,1.6,0);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff,0x808080,0.7); hemi.position.set(0,20,0); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(5,10,7); scene.add(dir);

    const root = new THREE.Group(); scene.add(root);

    // post
    const post = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,6,20), new THREE.MeshStandardMaterial({color:0x222033}));
    root.add(post);

    // grid + fog
    const gridHelper = new THREE.GridHelper(2000,2000,0x40e0d0,0x40e0d0); gridHelper.material.opacity=0.3; gridHelper.material.transparent=true; gridHelper.position.y=-3.05; scene.add(gridHelper);
    scene.fog = new THREE.FogExp2(0x222033,0.03);

    // --- Text + flag helpers ---
    function makeTextTexture(line1,line2,w=1024,h=256,color1='#222033',color2='#5d5f7c'){
      const canvas=document.createElement('canvas'); canvas.width=w; canvas.height=h; const ctx=canvas.getContext('2d');
      ctx.clearRect(0,0,w,h);
      const fontSize=Math.round(h*0.36); ctx.font = fontSize + 'px "Bebas Neue"'; ctx.textAlign='center'; ctx.textBaseline='middle';
      const lineSpacing = fontSize * 0.5; ctx.fillStyle=color1; ctx.fillText(line1,w/2,h/2-lineSpacing); ctx.fillStyle=color2; ctx.fillText(line2,w/2,h/2+fontSize*1.1-lineSpacing);
      const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true; return {tex,fontSize};
    }

    function createFlagCircleTexture(url,diam,cb){ const img=new Image(); img.crossOrigin='anonymous'; img.onload=()=>{ const c=document.createElement('canvas'); c.width=c.height=diam; const ctx=c.getContext('2d'); const size=Math.min(img.width,img.height); const sx=(img.width-size)/2, sy=(img.height-size)/2; ctx.beginPath(); ctx.arc(diam/2,diam/2,diam/2-1.5,0,Math.PI*2); ctx.closePath(); ctx.clip(); ctx.drawImage(img,sx,sy,size,size,0,0,diam,diam); ctx.lineWidth=3; ctx.strokeStyle='#222033'; ctx.beginPath(); ctx.arc(diam/2,diam/2,diam/2-1.5,0,Math.PI*2); ctx.closePath(); ctx.stroke(); const tex=new THREE.CanvasTexture(c); tex.needsUpdate=true; cb(tex); }; img.onerror=()=>{ cb(null); }; img.src=url; }

    const flagMap = {
      'CANADA': 'https://kapowaz.github.io/square-flags/flags/ca.svg',
      'BRAZIL': 'https://kapowaz.github.io/square-flags/flags/br.svg',
      'JAPAN': 'https://kapowaz.github.io/square-flags/flags/jp.svg',
      'SOUTH AFRICA': 'https://kapowaz.github.io/square-flags/flags/za.svg',
      'INDIA': 'https://kapowaz.github.io/square-flags/flags/in.svg',
      'AUSTRALIA': 'https://kapowaz.github.io/square-flags/flags/au.svg',
      'ARGENTINA': 'https://kapowaz.github.io/square-flags/flags/ar.svg',
      'MEXICO': 'https://kapowaz.github.io/square-flags/flags/mx.svg',
      'RUSSIA': 'https://kapowaz.github.io/square-flags/flags/ru.svg',
      'USA': 'https://kapowaz.github.io/square-flags/flags/us.svg'
    };

    // --- Create Sign ---
    function createSign(label,distance,angleDeg,y=1.5){
      const sign=new THREE.Group();
      const signW=2.6, signH=0.52, signD=0.05; const xCenter=1.55;
      const shape=new THREE.Shape(); shape.moveTo(0,-signH/2); shape.lineTo(signW-0.4,-signH/2); shape.lineTo(signW,0); shape.lineTo(signW-0.4,signH/2); shape.lineTo(0,signH/2); shape.closePath();
      const geom=new THREE.ExtrudeGeometry(shape,{depth:signD,bevelEnabled:false}); const body=new THREE.Mesh(geom,new THREE.MeshStandardMaterial({color:0xffffff}));
      const angleRad=THREE.MathUtils.degToRad(-angleDeg); sign.rotation.y=angleRad+Math.PI/2; body.position.set(xCenter-signW/2,y,-signD/2); sign.add(body);
      const colors = label==='N'?['#d6e160','#d6e160']:['#222033','#5d5f7c'];
      const {tex,fontSize} = makeTextTexture(label,distance,1024,256,colors[0],colors[1]); const textGeom=new THREE.PlaneGeometry(signW*0.8,signH*0.9);
      const textMat=new THREE.MeshBasicMaterial({map:tex,transparent:true}); const frontText=new THREE.Mesh(textGeom,textMat); frontText.position.set(xCenter,y,0.03); sign.add(frontText);
      const backText=new THREE.Mesh(textGeom,textMat.clone()); backText.position.set(xCenter,y,-0.03); backText.rotation.y=Math.PI; sign.add(backText);
      // pin: diameter reduced by ~33% (0.016 vs original 0.03) and same color as pole
      const pin = new THREE.Mesh(new THREE.CylinderGeometry(0.016,0.016,0.5,8), new THREE.MeshStandardMaterial({color:0x222033})); pin.rotation.z = Math.PI/2; pin.position.set(0.22,y,0); sign.add(pin);
      // flags
      const flagUrl = flagMap[label]; if(flagUrl){ createFlagCircleTexture(flagUrl, Math.max(32, Math.round(fontSize)), (flagTex)=>{ if(!flagTex) return; const flagMat=new THREE.MeshBasicMaterial({map:flagTex,transparent:true}); const worldRadius=(fontSize/512);
        const frontFlag=new THREE.Mesh(new THREE.CircleGeometry(worldRadius,64),flagMat); frontFlag.position.set(signW-0.4,y,0.06); sign.add(frontFlag);
        const backFlag=new THREE.Mesh(new THREE.CircleGeometry(worldRadius,64),flagMat); backFlag.position.set(signW-0.4,y,-0.06); backFlag.rotation.y=Math.PI; sign.add(backFlag);
      }); }
      return sign;
    }

    // --- Countries / signs ---
    const countries = [ ['CANADA','9,000 km',-45], ['BRAZIL','9,600 km',-120], ['JAPAN','9,300 km',80], ['SOUTH AFRICA','6,300 km',170], ['INDIA','4,400 km',95], ['AUSTRALIA','12,200 km',120], ['ARGENTINA','11,800 km',-150], ['MEXICO','12,400 km',-70], ['RUSSIA','2,800 km',40], ['USA','10,000 km',-60] ];
    let yStart = 2.6; const signs = countries.map((c,i)=>createSign(c[0],c[1],c[2], yStart - i*0.36));
    // only topmost visible
    let revealedCount = 1; root.add(signs[0]); const maxReveals = signs.length; document.getElementById('maxCount').textContent = String(maxReveals); document.getElementById('revealedCount').textContent = String(revealedCount);

    // --- Compass ring (dashed) + labels ---
    const signLength = 2.6; const compassRadius = signLength * 4; const segments = 256; const points = [];
    for(let i=0;i<=segments;i++){ const theta = (i/segments) * Math.PI * 2; points.push(new THREE.Vector3(Math.cos(theta)*compassRadius,0,Math.sin(theta)*compassRadius)); }
    const ringGeom = new THREE.BufferGeometry().setFromPoints(points); const ringMat = new THREE.LineDashedMaterial({color:0x444444,dashSize:0.2,gapSize:0.1}); const compassCircle = new THREE.LineLoop(ringGeom, ringMat); compassCircle.computeLineDistances(); compassCircle.rotation.x = -Math.PI/1; compassCircle.position.y = 3 * 1.3; root.add(compassCircle);

    function makeCompassLabel(text,scale=5,color='#fff'){ const base=256; const canvas=document.createElement('canvas'); canvas.width=canvas.height=base*scale; const ctx=canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle='rgba(255,255,255,0)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle=color; const fontSize=100*scale; ctx.font = fontSize + 'px "Bebas Neue"'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text, canvas.width/2, canvas.height/2); const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true; return { material: new THREE.MeshBasicMaterial({ map: tex, transparent:true, side: THREE.DoubleSide }), size: scale }; }

    const directions = [ ['N',180,'#d6e160',5], ['W',90,'#fff',5], ['S',0,'#fff',5], ['E',270,'#fff',5], ['NE',225,'#fff',2.5], ['NW',135,'#fff',2.5], ['SE',315,'#fff',2.5], ['SW',45,'#fff',2.5] ];
    directions.forEach(([label,angle,color,scale])=>{
      const { material: texMat, size } = makeCompassLabel(label, scale, color);
      const planeSize = 1 * size;
      const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(planeSize, planeSize), texMat);
      const rad = THREE.MathUtils.degToRad(angle);
      const outwardRadius = compassRadius + planeSize;
      const letterHeight = planeSize;
      textPlane.position.set(Math.sin(rad) * outwardRadius, 3*1.3 + letterHeight*0.5, Math.cos(rad) * outwardRadius);
      textPlane.rotation.y = Math.PI / 2;
      if(label === 'N') textPlane.rotation.y += Math.PI / 0.666;
      if(label === 'S') textPlane.rotation.y += Math.PI / 2;
      if(label === 'SW') textPlane.rotation.y += Math.PI / 0.36;
      if(label === 'SE') textPlane.rotation.y += Math.PI / 0.16;
      if(label === 'NE') textPlane.rotation.y += Math.PI / 0.56;
      if(label === 'NW') textPlane.rotation.y += Math.PI / 0.76;
      root.add(textPlane);

      // arrow
      const arrowHeight = letterHeight * 0.1;
      const arrowShape = new THREE.Shape(); arrowShape.moveTo(0,0); arrowShape.lineTo(arrowHeight*0.5,-arrowHeight); arrowShape.lineTo(-arrowHeight*0.5,-arrowHeight); arrowShape.closePath();
      const arrowGeom = new THREE.ShapeGeometry(arrowShape); const arrowMat = new THREE.MeshBasicMaterial({ color: label === 'N' ? '#d6e160' : '#ffffff', side: THREE.DoubleSide });
      const arrow = new THREE.Mesh(arrowGeom, arrowMat);
      arrow.rotation.x = -Math.PI/2; arrow.rotation.y = textPlane.rotation.y; arrow.rotation.x = textPlane.rotation.x;
      arrow.position.set(textPlane.position.x, textPlane.position.y + letterHeight*0.4, textPlane.position.z);
      root.add(arrow);
    });

    // --- Game data / UI ---
    let allCountries = [];
    const nameToUpper = new Map();

    // robust fetch with defensive checks
    fetch('https://restcountries.com/v3.1/all').then(r=>r.json()).then(d=>{
      let names = [];
      if(Array.isArray(d)){
        names = d.map(c => (c && c.name && (c.name.common || c.name.official)) || c.cca2 || '').filter(Boolean);
      } else if(d && Array.isArray(d.data)){
        names = d.data.map(c=>c.name).filter(Boolean);
      }
      // fallback to our limited list if API shape unexpected
      if(!names.length) names = countries.map(c=>c[0]);
      // dedupe & sort
      allCountries = Array.from(new Set(names)).sort((a,b)=>a.localeCompare(b));
      allCountries.forEach(n=>nameToUpper.set(n.toUpperCase(), n));
    }).catch(err=>{
      // on any error, fall back to provided countries
      allCountries = countries.map(c=>c[0]); allCountries.forEach(n=>nameToUpper.set(n.toUpperCase(), n));
      console.warn('Failed to load country list, using fallback', err);
    });

    const input = document.getElementById('guessInput');
    const button = document.getElementById('guessButton');
    const suggestionsBox = document.getElementById('suggestions');
    const attemptsEl = document.getElementById('revealedCount');
    const messageEl = document.getElementById('message');

    const correct = countries[0][0].toUpperCase();

    function showMessage(txt,timeout=2000){ messageEl.textContent = txt; if(timeout){ clearTimeout(showMessage._t); showMessage._t = setTimeout(()=>{ messageEl.textContent = 'Guess the country where the pole is located.'; }, timeout); } }

    function normalize(s){ return (s||'').trim().toUpperCase(); }

    function handleGuess(){ const raw=input.value; const g=normalize(raw); if(!g) return; const guessed = nameToUpper.get(g) || g;
      if(guessed === correct){ for(let i = revealedCount; i < signs.length; i++) root.add(signs[i]); revealedCount = signs.length; attemptsEl.textContent = String(revealedCount); showMessage('Correct — the pole is in ' + raw + '!'); input.disabled = true; button.disabled = true; }
      else{ if(revealedCount < maxReveals){ root.add(signs[revealedCount]); revealedCount++; attemptsEl.textContent = String(revealedCount); if(revealedCount >= maxReveals){ showMessage('Game over — out of reveals. The location was: ' + countries[0][0]); input.disabled = true; button.disabled = true; } else { showMessage('No — keep trying.'); } } }
      input.value = ''; suggestionsBox.style.display = 'none'; }

    button.addEventListener('click', handleGuess);
    input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ handleGuess(); } });

    // suggestions: only show countries starting with typed letters
    input.addEventListener('input', ()=>{
      const val = normalize(input.value);
      suggestionsBox.innerHTML = '';
      if(!val){ suggestionsBox.style.display = 'none'; return; }
      const matches = allCountries.filter(n => n.toUpperCase().startsWith(val));
      if(matches.length){ suggestionsBox.style.display = 'block'; matches.slice(0,12).forEach(name=>{ const d=document.createElement('div'); d.textContent = name; d.tabIndex = 0; d.addEventListener('click', ()=>{ input.value = name; suggestionsBox.style.display = 'none'; input.focus(); }); d.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ input.value = name; suggestionsBox.style.display='none'; input.focus(); } }); suggestionsBox.appendChild(d); }); }
      else { suggestionsBox.style.display = 'none'; }
    });

    // click outside to hide suggestions
    document.addEventListener('click', (e)=>{
      if(!e.target.closest('#suggestions') && !e.target.closest('#guessInput')) suggestionsBox.style.display = 'none';
    });

    // --- Drag to rotate ---
    let dragging=false, startX=0, startRot=0; function getX(e){ return e.touches && e.touches.length ? e.touches[0].clientX : e.clientX; }
    renderer.domElement.addEventListener('pointerdown', (e)=>{ dragging=true; startX=getX(e); startRot=root.rotation.y; renderer.domElement.setPointerCapture(e.pointerId); document.body.style.cursor='grabbing'; });
    window.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx = getX(e) - startX; root.rotation.y = startRot + (dx / window.innerWidth) * Math.PI; });
    window.addEventListener('pointerup', ()=>{ dragging=false; document.body.style.cursor=''; });

    // --- Render ---
    function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); } animate();
    window.addEventListener('resize', ()=>{ camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
  </script>
</body>
</html>
